# This file was generated by the Julia OpenAPI Code Generator
# Do not modify this file directly. Modify the OpenAPI specification instead.

struct UsersApi <: OpenAPI.APIClientImpl
    client::OpenAPI.Clients.Client
end

"""
The default API base path for APIs in `UsersApi`.
This can be used to construct the `OpenAPI.Clients.Client` instance.
"""
basepath(::Type{ UsersApi }) = "http://your-mattermost-url.com/api/v4"

const _returntypes_attach_device_id_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
)

function _oacinternal_attach_device_id(_api::UsersApi, attach_device_id_request::AttachDeviceIdRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_attach_device_id_UsersApi, "/users/sessions/device", ["bearerAuth", ], attach_device_id_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Attach mobile device

Attach a mobile device id to the currently logged in session. This will enable push notifications for a user, if configured by the server. ##### Permissions Must be authenticated. 

Params:
- attach_device_id_request::AttachDeviceIdRequest (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function attach_device_id(_api::UsersApi, attach_device_id_request::AttachDeviceIdRequest; _mediaType=nothing)
    _ctx = _oacinternal_attach_device_id(_api, attach_device_id_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function attach_device_id(_api::UsersApi, response_stream::Channel, attach_device_id_request::AttachDeviceIdRequest; _mediaType=nothing)
    _ctx = _oacinternal_attach_device_id(_api, attach_device_id_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_autocomplete_users_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => UserAutocomplete,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_autocomplete_users(_api::UsersApi, name::String; team_id=nothing, channel_id=nothing, limit=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_autocomplete_users_UsersApi, "/users/autocomplete", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "team_id", team_id)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "channel_id", channel_id)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "name", name)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "limit", limit)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Autocomplete users

Get a list of users for the purpose of autocompleting based on the provided search term. Specify a combination of `team_id` and `channel_id` to filter results further. ##### Permissions Requires an active session and `view_team` and `read_channel` on any teams or channels used to filter the results further. 

Params:
- name::String (required)
- team_id::String
- channel_id::String
- limit::Int64

Return: UserAutocomplete, OpenAPI.Clients.ApiResponse
"""
function autocomplete_users(_api::UsersApi, name::String; team_id=nothing, channel_id=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_autocomplete_users(_api, name; team_id=team_id, channel_id=channel_id, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function autocomplete_users(_api::UsersApi, response_stream::Channel, name::String; team_id=nothing, channel_id=nothing, limit=nothing, _mediaType=nothing)
    _ctx = _oacinternal_autocomplete_users(_api, name; team_id=team_id, channel_id=channel_id, limit=limit, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_check_user_mfa_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => CheckUserMfa200Response,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
)

function _oacinternal_check_user_mfa(_api::UsersApi, check_user_mfa_request::CheckUserMfaRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_check_user_mfa_UsersApi, "/users/mfa", ["bearerAuth", ], check_user_mfa_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Check MFA

Check if a user has multi-factor authentication active on their account by providing a login id. Used to check whether an MFA code needs to be provided when logging in. ##### Permissions No permission required. 

Params:
- check_user_mfa_request::CheckUserMfaRequest (required)

Return: CheckUserMfa200Response, OpenAPI.Clients.ApiResponse
"""
function check_user_mfa(_api::UsersApi, check_user_mfa_request::CheckUserMfaRequest; _mediaType=nothing)
    _ctx = _oacinternal_check_user_mfa(_api, check_user_mfa_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function check_user_mfa(_api::UsersApi, response_stream::Channel, check_user_mfa_request::CheckUserMfaRequest; _mediaType=nothing)
    _ctx = _oacinternal_check_user_mfa(_api, check_user_mfa_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_convert_bot_to_user_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
)

function _oacinternal_convert_bot_to_user(_api::UsersApi, bot_user_id::String, convert_bot_to_user_request::ConvertBotToUserRequest; set_system_admin=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_convert_bot_to_user_UsersApi, "/bots/{bot_user_id}/convert_to_user", ["bearerAuth", ], convert_bot_to_user_request)
    OpenAPI.Clients.set_param(_ctx.path, "bot_user_id", bot_user_id)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "set_system_admin", set_system_admin)  # type Bool
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Convert a bot into a user

Convert a bot into a user.  __Minimum server version__: 5.26  ##### Permissions Must have `manage_system` permission. 

Params:
- bot_user_id::String (required)
- convert_bot_to_user_request::ConvertBotToUserRequest (required)
- set_system_admin::Bool

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function convert_bot_to_user(_api::UsersApi, bot_user_id::String, convert_bot_to_user_request::ConvertBotToUserRequest; set_system_admin=nothing, _mediaType=nothing)
    _ctx = _oacinternal_convert_bot_to_user(_api, bot_user_id, convert_bot_to_user_request; set_system_admin=set_system_admin, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function convert_bot_to_user(_api::UsersApi, response_stream::Channel, bot_user_id::String, convert_bot_to_user_request::ConvertBotToUserRequest; set_system_admin=nothing, _mediaType=nothing)
    _ctx = _oacinternal_convert_bot_to_user(_api, bot_user_id, convert_bot_to_user_request; set_system_admin=set_system_admin, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_convert_user_to_bot_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
)

function _oacinternal_convert_user_to_bot(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_convert_user_to_bot_UsersApi, "/users/{user_id}/convert_to_bot", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Convert a user into a bot

Convert a user into a bot.  __Minimum server version__: 5.26  ##### Permissions Must have `manage_system` permission. 

Params:
- user_id::String (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function convert_user_to_bot(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_convert_user_to_bot(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function convert_user_to_bot(_api::UsersApi, response_stream::Channel, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_convert_user_to_bot(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_create_user_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("201", "x"=>".") * "\$") => User,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_create_user(_api::UsersApi, create_user_request::CreateUserRequest; t=nothing, iid=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_create_user_UsersApi, "/users", ["bearerAuth", ], create_user_request)
    OpenAPI.Clients.set_param(_ctx.query, "t", t)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "iid", iid)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Create a user

Create a new user on the system. Password is required for email login. For other authentication types such as LDAP or SAML, auth_data and auth_service fields are required. ##### Permissions No permission required for creating email/username accounts on an open server. Auth Token is required for other authentication types such as LDAP or SAML. 

Params:
- create_user_request::CreateUserRequest (required)
- t::String
- iid::String

Return: User, OpenAPI.Clients.ApiResponse
"""
function create_user(_api::UsersApi, create_user_request::CreateUserRequest; t=nothing, iid=nothing, _mediaType=nothing)
    _ctx = _oacinternal_create_user(_api, create_user_request; t=t, iid=iid, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function create_user(_api::UsersApi, response_stream::Channel, create_user_request::CreateUserRequest; t=nothing, iid=nothing, _mediaType=nothing)
    _ctx = _oacinternal_create_user(_api, create_user_request; t=t, iid=iid, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_create_user_access_token_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("201", "x"=>".") * "\$") => UserAccessToken,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_create_user_access_token(_api::UsersApi, user_id::String, create_user_access_token_request::CreateUserAccessTokenRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_create_user_access_token_UsersApi, "/users/{user_id}/tokens", ["bearerAuth", ], create_user_access_token_request)
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Create a user access token

Generate a user access token that can be used to authenticate with the Mattermost REST API.  __Minimum server version__: 4.1  ##### Permissions Must have `create_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission. 

Params:
- user_id::String (required)
- create_user_access_token_request::CreateUserAccessTokenRequest (required)

Return: UserAccessToken, OpenAPI.Clients.ApiResponse
"""
function create_user_access_token(_api::UsersApi, user_id::String, create_user_access_token_request::CreateUserAccessTokenRequest; _mediaType=nothing)
    _ctx = _oacinternal_create_user_access_token(_api, user_id, create_user_access_token_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function create_user_access_token(_api::UsersApi, response_stream::Channel, user_id::String, create_user_access_token_request::CreateUserAccessTokenRequest; _mediaType=nothing)
    _ctx = _oacinternal_create_user_access_token(_api, user_id, create_user_access_token_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_delete_user_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
)

function _oacinternal_delete_user(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "DELETE", _returntypes_delete_user_UsersApi, "/users/{user_id}", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Deactivate a user account.

Deactivates the user and revokes all its sessions by archiving its user object.  As of server version 5.28, optionally use the `permanent=true` query parameter to permanently delete the user for compliance reasons. To use this feature `ServiceSettings.EnableAPIUserDeletion` must be set to `true` in the server's configuration. ##### Permissions Must be logged in as the user being deactivated or have the `edit_other_users` permission. 

Params:
- user_id::String (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function delete_user(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_delete_user(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function delete_user(_api::UsersApi, response_stream::Channel, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_delete_user(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_demote_user_to_guest_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("501", "x"=>".") * "\$") => AppError,
)

function _oacinternal_demote_user_to_guest(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_demote_user_to_guest_UsersApi, "/users/{user_id}/demote", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Demote a user to a guest

Convert a regular user into a guest. This will convert the user into a guest for the whole system while retaining their existing team and channel memberships.  __Minimum server version__: 5.16  ##### Permissions Must be logged in as the user or have the `demote_to_guest` permission. 

Params:
- user_id::String (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function demote_user_to_guest(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_demote_user_to_guest(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function demote_user_to_guest(_api::UsersApi, response_stream::Channel, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_demote_user_to_guest(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_disable_user_access_token_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_disable_user_access_token(_api::UsersApi, disable_user_access_token_request::DisableUserAccessTokenRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_disable_user_access_token_UsersApi, "/users/tokens/disable", ["bearerAuth", ], disable_user_access_token_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Disable personal access token

Disable a personal access token and delete any sessions using the token. The token can be re-enabled using `/users/tokens/enable`.  __Minimum server version__: 4.4  ##### Permissions Must have `revoke_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission. 

Params:
- disable_user_access_token_request::DisableUserAccessTokenRequest (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function disable_user_access_token(_api::UsersApi, disable_user_access_token_request::DisableUserAccessTokenRequest; _mediaType=nothing)
    _ctx = _oacinternal_disable_user_access_token(_api, disable_user_access_token_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function disable_user_access_token(_api::UsersApi, response_stream::Channel, disable_user_access_token_request::DisableUserAccessTokenRequest; _mediaType=nothing)
    _ctx = _oacinternal_disable_user_access_token(_api, disable_user_access_token_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_enable_user_access_token_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_enable_user_access_token(_api::UsersApi, enable_user_access_token_request::EnableUserAccessTokenRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_enable_user_access_token_UsersApi, "/users/tokens/enable", ["bearerAuth", ], enable_user_access_token_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Enable personal access token

Re-enable a personal access token that has been disabled.  __Minimum server version__: 4.4  ##### Permissions Must have `create_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission. 

Params:
- enable_user_access_token_request::EnableUserAccessTokenRequest (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function enable_user_access_token(_api::UsersApi, enable_user_access_token_request::EnableUserAccessTokenRequest; _mediaType=nothing)
    _ctx = _oacinternal_enable_user_access_token(_api, enable_user_access_token_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function enable_user_access_token(_api::UsersApi, response_stream::Channel, enable_user_access_token_request::EnableUserAccessTokenRequest; _mediaType=nothing)
    _ctx = _oacinternal_enable_user_access_token(_api, enable_user_access_token_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_generate_mfa_secret_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => GenerateMfaSecret200Response,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("501", "x"=>".") * "\$") => AppError,
)

function _oacinternal_generate_mfa_secret(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_generate_mfa_secret_UsersApi, "/users/{user_id}/mfa/generate", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Generate MFA secret

Generates an multi-factor authentication secret for a user and returns it as a string and as base64 encoded QR code image. ##### Permissions Must be logged in as the user or have the `edit_other_users` permission. 

Params:
- user_id::String (required)

Return: GenerateMfaSecret200Response, OpenAPI.Clients.ApiResponse
"""
function generate_mfa_secret(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_generate_mfa_secret(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function generate_mfa_secret(_api::UsersApi, response_stream::Channel, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_generate_mfa_secret(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_channel_members_with_team_data_for_user_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{ChannelMemberWithTeamData},
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_channel_members_with_team_data_for_user(_api::UsersApi, user_id::String; page=nothing, page_size=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_channel_members_with_team_data_for_user_UsersApi, "/users/{user_id}/channel_members", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "page", page)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "pageSize", page_size)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get all channel members from all teams for a user

Get all channel members from all teams for a user.  __Minimum server version__: 6.2.0  ##### Permissions Logged in as the user, or have `edit_other_users` permission. 

Params:
- user_id::String (required)
- page::Int64
- page_size::Int64

Return: Vector{ChannelMemberWithTeamData}, OpenAPI.Clients.ApiResponse
"""
function get_channel_members_with_team_data_for_user(_api::UsersApi, user_id::String; page=nothing, page_size=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_channel_members_with_team_data_for_user(_api, user_id; page=page, page_size=page_size, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_channel_members_with_team_data_for_user(_api::UsersApi, response_stream::Channel, user_id::String; page=nothing, page_size=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_channel_members_with_team_data_for_user(_api, user_id; page=page, page_size=page_size, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_default_profile_image_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("501", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_default_profile_image(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_default_profile_image_UsersApi, "/users/{user_id}/image/default", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Return user's default (generated) profile image

Returns the default (generated) user profile image based on user_id string parameter. ##### Permissions Must be logged in. __Minimum server version__: 5.5 

Params:
- user_id::String (required)

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function get_default_profile_image(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_default_profile_image(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_default_profile_image(_api::UsersApi, response_stream::Channel, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_default_profile_image(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_known_users_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Any,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_known_users(_api::UsersApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_known_users_UsersApi, "/users/known", ["bearerAuth", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get user IDs of known users

Get the list of user IDs of users with any direct relationship with a user. That means any user sharing any channel, including direct and group channels. ##### Permissions Must be authenticated.  __Minimum server version__: 5.23 

Params:

Return: Any, OpenAPI.Clients.ApiResponse
"""
function get_known_users(_api::UsersApi; _mediaType=nothing)
    _ctx = _oacinternal_get_known_users(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_known_users(_api::UsersApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_get_known_users(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_profile_image_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("501", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_profile_image(_api::UsersApi, user_id::String; update_time=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_profile_image_UsersApi, "/users/{user_id}/image", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "update_time", update_time)  # type Float64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get user's profile image

Get a user's profile image based on user_id string parameter. ##### Permissions Must be logged in. 

Params:
- user_id::String (required)
- update_time::Float64

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function get_profile_image(_api::UsersApi, user_id::String; update_time=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_profile_image(_api, user_id; update_time=update_time, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_profile_image(_api::UsersApi, response_stream::Channel, user_id::String; update_time=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_profile_image(_api, user_id; update_time=update_time, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_sessions_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{Session},
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_sessions(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_sessions_UsersApi, "/users/{user_id}/sessions", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get user's sessions

Get a list of sessions by providing the user GUID. Sensitive information will be sanitized out. ##### Permissions Must be logged in as the user being updated or have the `edit_other_users` permission. 

Params:
- user_id::String (required)

Return: Vector{Session}, OpenAPI.Clients.ApiResponse
"""
function get_sessions(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_sessions(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_sessions(_api::UsersApi, response_stream::Channel, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_sessions(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_total_users_stats_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => UsersStats,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_total_users_stats(_api::UsersApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_total_users_stats_UsersApi, "/users/stats", ["bearerAuth", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get total count of users in the system

Get a total count of users in the system. ##### Permissions Must be authenticated. 

Params:

Return: UsersStats, OpenAPI.Clients.ApiResponse
"""
function get_total_users_stats(_api::UsersApi; _mediaType=nothing)
    _ctx = _oacinternal_get_total_users_stats(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_total_users_stats(_api::UsersApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_get_total_users_stats(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_total_users_stats_filtered_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => UsersStats,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_total_users_stats_filtered(_api::UsersApi; in_team=nothing, in_channel=nothing, include_deleted=nothing, include_bots=nothing, roles=nothing, channel_roles=nothing, team_roles=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_total_users_stats_filtered_UsersApi, "/users/stats/filtered", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "in_team", in_team)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "in_channel", in_channel)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "include_deleted", include_deleted)  # type Bool
    OpenAPI.Clients.set_param(_ctx.query, "include_bots", include_bots)  # type Bool
    OpenAPI.Clients.set_param(_ctx.query, "roles", roles)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "channel_roles", channel_roles)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "team_roles", team_roles)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get total count of users in the system matching the specified filters

Get a count of users in the system matching the specified filters.  __Minimum server version__: 5.26  ##### Permissions Must have `manage_system` permission. 

Params:
- in_team::String
- in_channel::String
- include_deleted::Bool
- include_bots::Bool
- roles::String
- channel_roles::String
- team_roles::String

Return: UsersStats, OpenAPI.Clients.ApiResponse
"""
function get_total_users_stats_filtered(_api::UsersApi; in_team=nothing, in_channel=nothing, include_deleted=nothing, include_bots=nothing, roles=nothing, channel_roles=nothing, team_roles=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_total_users_stats_filtered(_api; in_team=in_team, in_channel=in_channel, include_deleted=include_deleted, include_bots=include_bots, roles=roles, channel_roles=channel_roles, team_roles=team_roles, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_total_users_stats_filtered(_api::UsersApi, response_stream::Channel; in_team=nothing, in_channel=nothing, include_deleted=nothing, include_bots=nothing, roles=nothing, channel_roles=nothing, team_roles=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_total_users_stats_filtered(_api; in_team=in_team, in_channel=in_channel, include_deleted=include_deleted, include_bots=include_bots, roles=roles, channel_roles=channel_roles, team_roles=team_roles, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_uploads_for_user_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{UploadSession},
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_uploads_for_user(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_uploads_for_user_UsersApi, "/users/{user_id}/uploads", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get uploads for a user

Gets all the upload sessions belonging to a user.  __Minimum server version__: 5.28  ##### Permissions Must be logged in as the user who created the upload sessions. 

Params:
- user_id::String (required)

Return: Vector{UploadSession}, OpenAPI.Clients.ApiResponse
"""
function get_uploads_for_user(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_uploads_for_user(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_uploads_for_user(_api::UsersApi, response_stream::Channel, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_uploads_for_user(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_user_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => User,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_user(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_user_UsersApi, "/users/{user_id}", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get a user

Get a user a object. Sensitive information will be sanitized out. ##### Permissions Requires an active session but no other permissions. 

Params:
- user_id::String (required)

Return: User, OpenAPI.Clients.ApiResponse
"""
function get_user(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_user(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_user(_api::UsersApi, response_stream::Channel, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_user(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_user_access_token_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => UserAccessTokenSanitized,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_user_access_token(_api::UsersApi, token_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_user_access_token_UsersApi, "/users/tokens/{token_id}", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "token_id", token_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get a user access token

Get a user access token. Does not include the actual authentication token.  __Minimum server version__: 4.1  ##### Permissions Must have `read_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission. 

Params:
- token_id::String (required)

Return: UserAccessTokenSanitized, OpenAPI.Clients.ApiResponse
"""
function get_user_access_token(_api::UsersApi, token_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_user_access_token(_api, token_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_user_access_token(_api::UsersApi, response_stream::Channel, token_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_user_access_token(_api, token_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_user_access_tokens_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{UserAccessTokenSanitized},
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_user_access_tokens(_api::UsersApi; page=nothing, per_page=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_user_access_tokens_UsersApi, "/users/tokens", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "page", page)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "per_page", per_page)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get user access tokens

Get a page of user access tokens for users on the system. Does not include the actual authentication tokens. Use query parameters for paging.  __Minimum server version__: 4.7  ##### Permissions Must have `manage_system` permission. 

Params:
- page::Int64
- per_page::Int64

Return: Vector{UserAccessTokenSanitized}, OpenAPI.Clients.ApiResponse
"""
function get_user_access_tokens(_api::UsersApi; page=nothing, per_page=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_user_access_tokens(_api; page=page, per_page=per_page, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_user_access_tokens(_api::UsersApi, response_stream::Channel; page=nothing, per_page=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_user_access_tokens(_api; page=page, per_page=per_page, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_user_access_tokens_for_user_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{UserAccessTokenSanitized},
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_user_access_tokens_for_user(_api::UsersApi, user_id::String; page=nothing, per_page=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_user_access_tokens_for_user_UsersApi, "/users/{user_id}/tokens", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "page", page)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "per_page", per_page)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get user access tokens

Get a list of user access tokens for a user. Does not include the actual authentication tokens. Use query parameters for paging.  __Minimum server version__: 4.1  ##### Permissions Must have `read_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission. 

Params:
- user_id::String (required)
- page::Int64
- per_page::Int64

Return: Vector{UserAccessTokenSanitized}, OpenAPI.Clients.ApiResponse
"""
function get_user_access_tokens_for_user(_api::UsersApi, user_id::String; page=nothing, per_page=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_user_access_tokens_for_user(_api, user_id; page=page, per_page=per_page, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_user_access_tokens_for_user(_api::UsersApi, response_stream::Channel, user_id::String; page=nothing, per_page=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_user_access_tokens_for_user(_api, user_id; page=page, per_page=per_page, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_user_audits_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{Audit},
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_user_audits(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_user_audits_UsersApi, "/users/{user_id}/audits", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get user's audits

Get a list of audit by providing the user GUID. ##### Permissions Must be logged in as the user or have the `edit_other_users` permission. 

Params:
- user_id::String (required)

Return: Vector{Audit}, OpenAPI.Clients.ApiResponse
"""
function get_user_audits(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_user_audits(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_user_audits(_api::UsersApi, response_stream::Channel, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_user_audits(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_user_by_email_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => User,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_user_by_email(_api::UsersApi, email::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_user_by_email_UsersApi, "/users/email/{email}", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "email", email)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get a user by email

Get a user object by providing a user email. Sensitive information will be sanitized out. ##### Permissions Requires an active session and for the current session to be able to view another user's email based on the server's privacy settings. 

Params:
- email::String (required)

Return: User, OpenAPI.Clients.ApiResponse
"""
function get_user_by_email(_api::UsersApi, email::String; _mediaType=nothing)
    _ctx = _oacinternal_get_user_by_email(_api, email; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_user_by_email(_api::UsersApi, response_stream::Channel, email::String; _mediaType=nothing)
    _ctx = _oacinternal_get_user_by_email(_api, email; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_user_by_username_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => User,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_user_by_username(_api::UsersApi, username::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_user_by_username_UsersApi, "/users/username/{username}", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "username", username)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get a user by username

Get a user object by providing a username. Sensitive information will be sanitized out. ##### Permissions Requires an active session but no other permissions. 

Params:
- username::String (required)

Return: User, OpenAPI.Clients.ApiResponse
"""
function get_user_by_username(_api::UsersApi, username::String; _mediaType=nothing)
    _ctx = _oacinternal_get_user_by_username(_api, username; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_user_by_username(_api::UsersApi, response_stream::Channel, username::String; _mediaType=nothing)
    _ctx = _oacinternal_get_user_by_username(_api, username; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_user_terms_of_service_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => UserTermsOfService,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_user_terms_of_service(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_user_terms_of_service_UsersApi, "/users/{user_id}/terms_of_service", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Fetches user's latest terms of service action if the latest action was for acceptance.

Will be deprecated in v6.0 Fetches user's latest terms of service action if the latest action was for acceptance.  __Minimum server version__: 5.6 ##### Permissions Must be logged in as the user being acted on. 

Params:
- user_id::String (required)

Return: UserTermsOfService, OpenAPI.Clients.ApiResponse
"""
function get_user_terms_of_service(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_user_terms_of_service(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_user_terms_of_service(_api::UsersApi, response_stream::Channel, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_get_user_terms_of_service(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_users_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{User},
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_users(_api::UsersApi; page=nothing, per_page=nothing, in_team=nothing, not_in_team=nothing, in_channel=nothing, not_in_channel=nothing, in_group=nothing, group_constrained=nothing, without_team=nothing, active=nothing, inactive=nothing, role=nothing, sort=nothing, roles=nothing, channel_roles=nothing, team_roles=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "GET", _returntypes_get_users_UsersApi, "/users", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.query, "page", page)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "per_page", per_page)  # type Int64
    OpenAPI.Clients.set_param(_ctx.query, "in_team", in_team)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "not_in_team", not_in_team)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "in_channel", in_channel)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "not_in_channel", not_in_channel)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "in_group", in_group)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "group_constrained", group_constrained)  # type Bool
    OpenAPI.Clients.set_param(_ctx.query, "without_team", without_team)  # type Bool
    OpenAPI.Clients.set_param(_ctx.query, "active", active)  # type Bool
    OpenAPI.Clients.set_param(_ctx.query, "inactive", inactive)  # type Bool
    OpenAPI.Clients.set_param(_ctx.query, "role", role)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "sort", sort)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "roles", roles)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "channel_roles", channel_roles)  # type String
    OpenAPI.Clients.set_param(_ctx.query, "team_roles", team_roles)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Get users

Get a page of a list of users. Based on query string parameters, select users from a team, channel, or select users not in a specific channel.  Since server version 4.0, some basic sorting is available using the `sort` query parameter. Sorting is currently only supported when selecting users on a team. ##### Permissions Requires an active session and (if specified) membership to the channel or team being selected from. 

Params:
- page::Int64
- per_page::Int64
- in_team::String
- not_in_team::String
- in_channel::String
- not_in_channel::String
- in_group::String
- group_constrained::Bool
- without_team::Bool
- active::Bool
- inactive::Bool
- role::String
- sort::String
- roles::String
- channel_roles::String
- team_roles::String

Return: Vector{User}, OpenAPI.Clients.ApiResponse
"""
function get_users(_api::UsersApi; page=nothing, per_page=nothing, in_team=nothing, not_in_team=nothing, in_channel=nothing, not_in_channel=nothing, in_group=nothing, group_constrained=nothing, without_team=nothing, active=nothing, inactive=nothing, role=nothing, sort=nothing, roles=nothing, channel_roles=nothing, team_roles=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_users(_api; page=page, per_page=per_page, in_team=in_team, not_in_team=not_in_team, in_channel=in_channel, not_in_channel=not_in_channel, in_group=in_group, group_constrained=group_constrained, without_team=without_team, active=active, inactive=inactive, role=role, sort=sort, roles=roles, channel_roles=channel_roles, team_roles=team_roles, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_users(_api::UsersApi, response_stream::Channel; page=nothing, per_page=nothing, in_team=nothing, not_in_team=nothing, in_channel=nothing, not_in_channel=nothing, in_group=nothing, group_constrained=nothing, without_team=nothing, active=nothing, inactive=nothing, role=nothing, sort=nothing, roles=nothing, channel_roles=nothing, team_roles=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_users(_api; page=page, per_page=per_page, in_team=in_team, not_in_team=not_in_team, in_channel=in_channel, not_in_channel=not_in_channel, in_group=in_group, group_constrained=group_constrained, without_team=without_team, active=active, inactive=inactive, role=role, sort=sort, roles=roles, channel_roles=channel_roles, team_roles=team_roles, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_users_by_group_channel_ids_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => GetUsersByGroupChannelIds200Response,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_users_by_group_channel_ids(_api::UsersApi, request_body::Vector{String}; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_get_users_by_group_channel_ids_UsersApi, "/users/group_channels", ["bearerAuth", ], request_body)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Get users by group channels ids

Get an object containing a key per group channel id in the query and its value as a list of users members of that group channel.  The user must be a member of the group ids in the query, or they will be omitted from the response. ##### Permissions Requires an active session but no other permissions.  __Minimum server version__: 5.14 

Params:
- request_body::Vector{String} (required)

Return: GetUsersByGroupChannelIds200Response, OpenAPI.Clients.ApiResponse
"""
function get_users_by_group_channel_ids(_api::UsersApi, request_body::Vector{String}; _mediaType=nothing)
    _ctx = _oacinternal_get_users_by_group_channel_ids(_api, request_body; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_users_by_group_channel_ids(_api::UsersApi, response_stream::Channel, request_body::Vector{String}; _mediaType=nothing)
    _ctx = _oacinternal_get_users_by_group_channel_ids(_api, request_body; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_users_by_ids_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{User},
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_users_by_ids(_api::UsersApi, request_body::Vector{String}; since=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_get_users_by_ids_UsersApi, "/users/ids", ["bearerAuth", ], request_body)
    OpenAPI.Clients.set_param(_ctx.query, "since", since)  # type Int64
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Get users by ids

Get a list of users based on a provided list of user ids. ##### Permissions Requires an active session but no other permissions. 

Params:
- request_body::Vector{String} (required)
- since::Int64

Return: Vector{User}, OpenAPI.Clients.ApiResponse
"""
function get_users_by_ids(_api::UsersApi, request_body::Vector{String}; since=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_users_by_ids(_api, request_body; since=since, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_users_by_ids(_api::UsersApi, response_stream::Channel, request_body::Vector{String}; since=nothing, _mediaType=nothing)
    _ctx = _oacinternal_get_users_by_ids(_api, request_body; since=since, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_get_users_by_usernames_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{User},
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
)

function _oacinternal_get_users_by_usernames(_api::UsersApi, request_body::Vector{String}; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_get_users_by_usernames_UsersApi, "/users/usernames", ["bearerAuth", ], request_body)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Get users by usernames

Get a list of users based on a provided list of usernames. ##### Permissions Requires an active session but no other permissions. 

Params:
- request_body::Vector{String} (required)

Return: Vector{User}, OpenAPI.Clients.ApiResponse
"""
function get_users_by_usernames(_api::UsersApi, request_body::Vector{String}; _mediaType=nothing)
    _ctx = _oacinternal_get_users_by_usernames(_api, request_body; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function get_users_by_usernames(_api::UsersApi, response_stream::Channel, request_body::Vector{String}; _mediaType=nothing)
    _ctx = _oacinternal_get_users_by_usernames(_api, request_body; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_login_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("201", "x"=>".") * "\$") => User,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_login(_api::UsersApi, login_request::LoginRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_login_UsersApi, "/users/login", ["bearerAuth", ], login_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Login to Mattermost server

##### Permissions No permission required 

Params:
- login_request::LoginRequest (required)

Return: User, OpenAPI.Clients.ApiResponse
"""
function login(_api::UsersApi, login_request::LoginRequest; _mediaType=nothing)
    _ctx = _oacinternal_login(_api, login_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function login(_api::UsersApi, response_stream::Channel, login_request::LoginRequest; _mediaType=nothing)
    _ctx = _oacinternal_login(_api, login_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_login_by_cws_token_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("302", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_login_by_cws_token(_api::UsersApi, login_by_cws_token_request::LoginByCwsTokenRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_login_by_cws_token_UsersApi, "/users/login/cws", ["bearerAuth", ], login_by_cws_token_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Auto-Login to Mattermost server using CWS token

CWS stands for Customer Web Server which is the cloud service used to manage cloud instances. ##### Permissions A Cloud license is required 

Params:
- login_by_cws_token_request::LoginByCwsTokenRequest (required)

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function login_by_cws_token(_api::UsersApi, login_by_cws_token_request::LoginByCwsTokenRequest; _mediaType=nothing)
    _ctx = _oacinternal_login_by_cws_token(_api, login_by_cws_token_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function login_by_cws_token(_api::UsersApi, response_stream::Channel, login_by_cws_token_request::LoginByCwsTokenRequest; _mediaType=nothing)
    _ctx = _oacinternal_login_by_cws_token(_api, login_by_cws_token_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_logout_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("201", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_logout(_api::UsersApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_logout_UsersApi, "/users/logout", ["bearerAuth", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Logout from the Mattermost server

##### Permissions An active session is required 

Params:

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function logout(_api::UsersApi; _mediaType=nothing)
    _ctx = _oacinternal_logout(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function logout(_api::UsersApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_logout(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_migrate_auth_to_ldap_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("501", "x"=>".") * "\$") => AppError,
)

function _oacinternal_migrate_auth_to_ldap(_api::UsersApi; migrate_auth_to_ldap_request=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_migrate_auth_to_ldap_UsersApi, "/users/migrate_auth/ldap", ["bearerAuth", ], migrate_auth_to_ldap_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Migrate user accounts authentication type to LDAP.

Migrates accounts from one authentication provider to another. For example, you can upgrade your authentication provider from email to LDAP. __Minimum server version__: 5.28 ##### Permissions Must have `manage_system` permission. 

Params:
- migrate_auth_to_ldap_request::MigrateAuthToLdapRequest

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function migrate_auth_to_ldap(_api::UsersApi; migrate_auth_to_ldap_request=nothing, _mediaType=nothing)
    _ctx = _oacinternal_migrate_auth_to_ldap(_api; migrate_auth_to_ldap_request=migrate_auth_to_ldap_request, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function migrate_auth_to_ldap(_api::UsersApi, response_stream::Channel; migrate_auth_to_ldap_request=nothing, _mediaType=nothing)
    _ctx = _oacinternal_migrate_auth_to_ldap(_api; migrate_auth_to_ldap_request=migrate_auth_to_ldap_request, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_migrate_auth_to_saml_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("501", "x"=>".") * "\$") => AppError,
)

function _oacinternal_migrate_auth_to_saml(_api::UsersApi; migrate_auth_to_saml_request=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_migrate_auth_to_saml_UsersApi, "/users/migrate_auth/saml", ["bearerAuth", ], migrate_auth_to_saml_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Migrate user accounts authentication type to SAML.

Migrates accounts from one authentication provider to another. For example, you can upgrade your authentication provider from email to SAML. __Minimum server version__: 5.28 ##### Permissions Must have `manage_system` permission. 

Params:
- migrate_auth_to_saml_request::MigrateAuthToSamlRequest

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function migrate_auth_to_saml(_api::UsersApi; migrate_auth_to_saml_request=nothing, _mediaType=nothing)
    _ctx = _oacinternal_migrate_auth_to_saml(_api; migrate_auth_to_saml_request=migrate_auth_to_saml_request, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function migrate_auth_to_saml(_api::UsersApi, response_stream::Channel; migrate_auth_to_saml_request=nothing, _mediaType=nothing)
    _ctx = _oacinternal_migrate_auth_to_saml(_api; migrate_auth_to_saml_request=migrate_auth_to_saml_request, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_patch_user_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => User,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_patch_user(_api::UsersApi, user_id::String, patch_user_request::PatchUserRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_patch_user_UsersApi, "/users/{user_id}/patch", ["bearerAuth", ], patch_user_request)
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Patch a user

Partially update a user by providing only the fields you want to update. Omitted fields will not be updated. The fields that can be updated are defined in the request body, all other provided fields will be ignored. ##### Permissions Must be logged in as the user being updated or have the `edit_other_users` permission. 

Params:
- user_id::String (required)
- patch_user_request::PatchUserRequest (required)

Return: User, OpenAPI.Clients.ApiResponse
"""
function patch_user(_api::UsersApi, user_id::String, patch_user_request::PatchUserRequest; _mediaType=nothing)
    _ctx = _oacinternal_patch_user(_api, user_id, patch_user_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function patch_user(_api::UsersApi, response_stream::Channel, user_id::String, patch_user_request::PatchUserRequest; _mediaType=nothing)
    _ctx = _oacinternal_patch_user(_api, user_id, patch_user_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_permanent_delete_all_users_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Nothing,
)

function _oacinternal_permanent_delete_all_users(_api::UsersApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "DELETE", _returntypes_permanent_delete_all_users_UsersApi, "/users", ["bearerAuth", ])
    OpenAPI.Clients.set_header_accept(_ctx, [])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Permanent delete all users

Permanently deletes all users and all their related information, including posts.  __Minimum server version__: 5.26.0  __Local mode only__: This endpoint is only available through [local mode](https://docs.mattermost.com/administration/mmctl-cli-tool.html#local-mode). 

Params:

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function permanent_delete_all_users(_api::UsersApi; _mediaType=nothing)
    _ctx = _oacinternal_permanent_delete_all_users(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function permanent_delete_all_users(_api::UsersApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_permanent_delete_all_users(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_promote_guest_to_user_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("501", "x"=>".") * "\$") => AppError,
)

function _oacinternal_promote_guest_to_user(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_promote_guest_to_user_UsersApi, "/users/{user_id}/promote", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Promote a guest to user

Convert a guest into a regular user. This will convert the guest into a user for the whole system while retaining any team and channel memberships and automatically joining them to the default channels.  __Minimum server version__: 5.16  ##### Permissions Must be logged in as the user or have the `promote_guest` permission. 

Params:
- user_id::String (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function promote_guest_to_user(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_promote_guest_to_user(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function promote_guest_to_user(_api::UsersApi, response_stream::Channel, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_promote_guest_to_user(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_publish_user_typing_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_publish_user_typing(_api::UsersApi, user_id::String; publish_user_typing_request=nothing, _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_publish_user_typing_UsersApi, "/users/{user_id}/typing", ["bearerAuth", ], publish_user_typing_request)
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Publish a user typing websocket event.

Notify users in the given channel via websocket that the given user is typing. __Minimum server version__: 5.26 ##### Permissions Must have `manage_system` permission to publish for any user other than oneself. 

Params:
- user_id::String (required)
- publish_user_typing_request::PublishUserTypingRequest

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function publish_user_typing(_api::UsersApi, user_id::String; publish_user_typing_request=nothing, _mediaType=nothing)
    _ctx = _oacinternal_publish_user_typing(_api, user_id; publish_user_typing_request=publish_user_typing_request, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function publish_user_typing(_api::UsersApi, response_stream::Channel, user_id::String; publish_user_typing_request=nothing, _mediaType=nothing)
    _ctx = _oacinternal_publish_user_typing(_api, user_id; publish_user_typing_request=publish_user_typing_request, _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_register_terms_of_service_action_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_register_terms_of_service_action(_api::UsersApi, user_id::String, register_terms_of_service_action_request::RegisterTermsOfServiceActionRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_register_terms_of_service_action_UsersApi, "/users/{user_id}/terms_of_service", ["bearerAuth", ], register_terms_of_service_action_request)
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Records user action when they accept or decline custom terms of service

Records user action when they accept or decline custom terms of service. Records the action in audit table. Updates user's last accepted terms of service ID if they accepted it.  __Minimum server version__: 5.4 ##### Permissions Must be logged in as the user being acted on. 

Params:
- user_id::String (required)
- register_terms_of_service_action_request::RegisterTermsOfServiceActionRequest (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function register_terms_of_service_action(_api::UsersApi, user_id::String, register_terms_of_service_action_request::RegisterTermsOfServiceActionRequest; _mediaType=nothing)
    _ctx = _oacinternal_register_terms_of_service_action(_api, user_id, register_terms_of_service_action_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function register_terms_of_service_action(_api::UsersApi, response_stream::Channel, user_id::String, register_terms_of_service_action_request::RegisterTermsOfServiceActionRequest; _mediaType=nothing)
    _ctx = _oacinternal_register_terms_of_service_action(_api, user_id, register_terms_of_service_action_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_reset_password_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_reset_password(_api::UsersApi, reset_password_request::ResetPasswordRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_reset_password_UsersApi, "/users/password/reset", ["bearerAuth", ], reset_password_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Reset password

Update the password for a user using a one-use, timed recovery code tied to the user's account. Only works for non-SSO users. ##### Permissions No permissions required. 

Params:
- reset_password_request::ResetPasswordRequest (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function reset_password(_api::UsersApi, reset_password_request::ResetPasswordRequest; _mediaType=nothing)
    _ctx = _oacinternal_reset_password(_api, reset_password_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function reset_password(_api::UsersApi, response_stream::Channel, reset_password_request::ResetPasswordRequest; _mediaType=nothing)
    _ctx = _oacinternal_reset_password(_api, reset_password_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_revoke_all_sessions_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_revoke_all_sessions(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_revoke_all_sessions_UsersApi, "/users/{user_id}/sessions/revoke/all", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Revoke all active sessions for a user

Revokes all user sessions from the provided user id and session id strings. ##### Permissions Must be logged in as the user being updated or have the `edit_other_users` permission. __Minimum server version__: 4.4 

Params:
- user_id::String (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function revoke_all_sessions(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_revoke_all_sessions(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function revoke_all_sessions(_api::UsersApi, response_stream::Channel, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_revoke_all_sessions(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_revoke_session_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_revoke_session(_api::UsersApi, user_id::String, revoke_session_request::RevokeSessionRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_revoke_session_UsersApi, "/users/{user_id}/sessions/revoke", ["bearerAuth", ], revoke_session_request)
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Revoke a user session

Revokes a user session from the provided user id and session id strings. ##### Permissions Must be logged in as the user being updated or have the `edit_other_users` permission. 

Params:
- user_id::String (required)
- revoke_session_request::RevokeSessionRequest (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function revoke_session(_api::UsersApi, user_id::String, revoke_session_request::RevokeSessionRequest; _mediaType=nothing)
    _ctx = _oacinternal_revoke_session(_api, user_id, revoke_session_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function revoke_session(_api::UsersApi, response_stream::Channel, user_id::String, revoke_session_request::RevokeSessionRequest; _mediaType=nothing)
    _ctx = _oacinternal_revoke_session(_api, user_id, revoke_session_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_revoke_sessions_from_all_users_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Nothing,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_revoke_sessions_from_all_users(_api::UsersApi; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_revoke_sessions_from_all_users_UsersApi, "/users/sessions/revoke/all", ["bearerAuth", ])
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Revoke all sessions from all users.

For any session currently on the server (including admin) it will be revoked. Clients will be notified to log out users.  __Minimum server version__: 5.14  ##### Permissions Must have `manage_system` permission. 

Params:

Return: Nothing, OpenAPI.Clients.ApiResponse
"""
function revoke_sessions_from_all_users(_api::UsersApi; _mediaType=nothing)
    _ctx = _oacinternal_revoke_sessions_from_all_users(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function revoke_sessions_from_all_users(_api::UsersApi, response_stream::Channel; _mediaType=nothing)
    _ctx = _oacinternal_revoke_sessions_from_all_users(_api; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_revoke_user_access_token_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_revoke_user_access_token(_api::UsersApi, revoke_user_access_token_request::RevokeUserAccessTokenRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_revoke_user_access_token_UsersApi, "/users/tokens/revoke", ["bearerAuth", ], revoke_user_access_token_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Revoke a user access token

Revoke a user access token and delete any sessions using the token.  __Minimum server version__: 4.1  ##### Permissions Must have `revoke_user_access_token` permission. For non-self requests, must also have the `edit_other_users` permission. 

Params:
- revoke_user_access_token_request::RevokeUserAccessTokenRequest (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function revoke_user_access_token(_api::UsersApi, revoke_user_access_token_request::RevokeUserAccessTokenRequest; _mediaType=nothing)
    _ctx = _oacinternal_revoke_user_access_token(_api, revoke_user_access_token_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function revoke_user_access_token(_api::UsersApi, response_stream::Channel, revoke_user_access_token_request::RevokeUserAccessTokenRequest; _mediaType=nothing)
    _ctx = _oacinternal_revoke_user_access_token(_api, revoke_user_access_token_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_search_user_access_tokens_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{UserAccessTokenSanitized},
)

function _oacinternal_search_user_access_tokens(_api::UsersApi, search_user_access_tokens_request::SearchUserAccessTokensRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_search_user_access_tokens_UsersApi, "/users/tokens/search", ["bearerAuth", ], search_user_access_tokens_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Search tokens

Get a list of tokens based on search criteria provided in the request body. Searches are done against the token id, user id and username.  __Minimum server version__: 4.7  ##### Permissions Must have `manage_system` permission. 

Params:
- search_user_access_tokens_request::SearchUserAccessTokensRequest (required)

Return: Vector{UserAccessTokenSanitized}, OpenAPI.Clients.ApiResponse
"""
function search_user_access_tokens(_api::UsersApi, search_user_access_tokens_request::SearchUserAccessTokensRequest; _mediaType=nothing)
    _ctx = _oacinternal_search_user_access_tokens(_api, search_user_access_tokens_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function search_user_access_tokens(_api::UsersApi, response_stream::Channel, search_user_access_tokens_request::SearchUserAccessTokensRequest; _mediaType=nothing)
    _ctx = _oacinternal_search_user_access_tokens(_api, search_user_access_tokens_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_search_users_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => Vector{User},
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_search_users(_api::UsersApi, search_users_request::SearchUsersRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_search_users_UsersApi, "/users/search", ["bearerAuth", ], search_users_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Search users

Get a list of users based on search criteria provided in the request body. Searches are typically done against username, full name, nickname and email unless otherwise configured by the server. ##### Permissions Requires an active session and `read_channel` and/or `view_team` permissions for any channels or teams specified in the request body. 

Params:
- search_users_request::SearchUsersRequest (required)

Return: Vector{User}, OpenAPI.Clients.ApiResponse
"""
function search_users(_api::UsersApi, search_users_request::SearchUsersRequest; _mediaType=nothing)
    _ctx = _oacinternal_search_users(_api, search_users_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function search_users(_api::UsersApi, response_stream::Channel, search_users_request::SearchUsersRequest; _mediaType=nothing)
    _ctx = _oacinternal_search_users(_api, search_users_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_send_password_reset_email_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_send_password_reset_email(_api::UsersApi, send_password_reset_email_request::SendPasswordResetEmailRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_send_password_reset_email_UsersApi, "/users/password/reset/send", ["bearerAuth", ], send_password_reset_email_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Send password reset email

Send an email containing a link for resetting the user's password. The link will contain a one-use, timed recovery code tied to the user's account. Only works for non-SSO users. ##### Permissions No permissions required. 

Params:
- send_password_reset_email_request::SendPasswordResetEmailRequest (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function send_password_reset_email(_api::UsersApi, send_password_reset_email_request::SendPasswordResetEmailRequest; _mediaType=nothing)
    _ctx = _oacinternal_send_password_reset_email(_api, send_password_reset_email_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function send_password_reset_email(_api::UsersApi, response_stream::Channel, send_password_reset_email_request::SendPasswordResetEmailRequest; _mediaType=nothing)
    _ctx = _oacinternal_send_password_reset_email(_api, send_password_reset_email_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_send_verification_email_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
)

function _oacinternal_send_verification_email(_api::UsersApi, send_verification_email_request::SendVerificationEmailRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_send_verification_email_UsersApi, "/users/email/verify/send", ["bearerAuth", ], send_verification_email_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Send verification email

Send an email with a verification link to a user that has an email matching the one in the request body. This endpoint will return success even if the email does not match any users on the system. ##### Permissions No permissions required. 

Params:
- send_verification_email_request::SendVerificationEmailRequest (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function send_verification_email(_api::UsersApi, send_verification_email_request::SendVerificationEmailRequest; _mediaType=nothing)
    _ctx = _oacinternal_send_verification_email(_api, send_verification_email_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function send_verification_email(_api::UsersApi, response_stream::Channel, send_verification_email_request::SendVerificationEmailRequest; _mediaType=nothing)
    _ctx = _oacinternal_send_verification_email(_api, send_verification_email_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_set_default_profile_image_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("501", "x"=>".") * "\$") => AppError,
)

function _oacinternal_set_default_profile_image(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "DELETE", _returntypes_set_default_profile_image_UsersApi, "/users/{user_id}/image", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Delete user's profile image

Delete user's profile image and reset to default image based on user_id string parameter. ##### Permissions Must be logged in as the user being updated or have the `edit_other_users` permission. __Minimum server version__: 5.5 

Params:
- user_id::String (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function set_default_profile_image(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_set_default_profile_image(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function set_default_profile_image(_api::UsersApi, response_stream::Channel, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_set_default_profile_image(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_set_profile_image_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("501", "x"=>".") * "\$") => AppError,
)

function _oacinternal_set_profile_image(_api::UsersApi, user_id::String, image::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_set_profile_image_UsersApi, "/users/{user_id}/image", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_param(_ctx.file, "image", image)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["multipart/form-data", ] : [_mediaType])
    return _ctx
end

@doc raw"""Set user's profile image

Set a user's profile image based on user_id string parameter. ##### Permissions Must be logged in as the user being updated or have the `edit_other_users` permission. 

Params:
- user_id::String (required)
- image::String (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function set_profile_image(_api::UsersApi, user_id::String, image::String; _mediaType=nothing)
    _ctx = _oacinternal_set_profile_image(_api, user_id, image; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function set_profile_image(_api::UsersApi, response_stream::Channel, user_id::String, image::String; _mediaType=nothing)
    _ctx = _oacinternal_set_profile_image(_api, user_id, image; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_switch_account_type_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => SwitchAccountType200Response,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("501", "x"=>".") * "\$") => AppError,
)

function _oacinternal_switch_account_type(_api::UsersApi, switch_account_type_request::SwitchAccountTypeRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_switch_account_type_UsersApi, "/users/login/switch", ["bearerAuth", ], switch_account_type_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Switch login method

Switch a user's login method from using email to OAuth2/SAML/LDAP or back to email. When switching to OAuth2/SAML, account switching is not complete until the user follows the returned link and completes any steps on the OAuth2/SAML service provider.  To switch from email to OAuth2/SAML, specify `current_service`, `new_service`, `email` and `password`.  To switch from OAuth2/SAML to email, specify `current_service`, `new_service`, `email` and `new_password`.  To switch from email to LDAP/AD, specify `current_service`, `new_service`, `email`, `password`, `ldap_ip` and `new_password` (this is the user's LDAP password).  To switch from LDAP/AD to email, specify `current_service`, `new_service`, `ldap_ip`, `password` (this is the user's LDAP password), `email`  and `new_password`.  Additionally, specify `mfa_code` when trying to switch an account on LDAP/AD or email that has MFA activated.  ##### Permissions No current authentication required except when switching from OAuth2/SAML to email. 

Params:
- switch_account_type_request::SwitchAccountTypeRequest (required)

Return: SwitchAccountType200Response, OpenAPI.Clients.ApiResponse
"""
function switch_account_type(_api::UsersApi, switch_account_type_request::SwitchAccountTypeRequest; _mediaType=nothing)
    _ctx = _oacinternal_switch_account_type(_api, switch_account_type_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function switch_account_type(_api::UsersApi, response_stream::Channel, switch_account_type_request::SwitchAccountTypeRequest; _mediaType=nothing)
    _ctx = _oacinternal_switch_account_type(_api, switch_account_type_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_update_user_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => User,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_update_user(_api::UsersApi, user_id::String, update_user_request::UpdateUserRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_update_user_UsersApi, "/users/{user_id}", ["bearerAuth", ], update_user_request)
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Update a user

Update a user by providing the user object. The fields that can be updated are defined in the request body, all other provided fields will be ignored. Any fields not included in the request body will be set to null or reverted to default values. ##### Permissions Must be logged in as the user being updated or have the `edit_other_users` permission. 

Params:
- user_id::String (required)
- update_user_request::UpdateUserRequest (required)

Return: User, OpenAPI.Clients.ApiResponse
"""
function update_user(_api::UsersApi, user_id::String, update_user_request::UpdateUserRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_user(_api, user_id, update_user_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function update_user(_api::UsersApi, response_stream::Channel, user_id::String, update_user_request::UpdateUserRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_user(_api, user_id, update_user_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_update_user_active_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_update_user_active(_api::UsersApi, user_id::String, update_user_active_request::UpdateUserActiveRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_update_user_active_UsersApi, "/users/{user_id}/active", ["bearerAuth", ], update_user_active_request)
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Update user active status

Update user active or inactive status.  __Since server version 4.6, users using a SSO provider to login can be activated or deactivated with this endpoint. However, if their activation status in Mattermost does not reflect their status in the SSO provider, the next synchronization or login by that user will reset the activation status to that of their account in the SSO provider. Server versions 4.5 and before do not allow activation or deactivation of SSO users from this endpoint.__ ##### Permissions User can deactivate themselves. User with `manage_system` permission can activate or deactivate a user. 

Params:
- user_id::String (required)
- update_user_active_request::UpdateUserActiveRequest (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function update_user_active(_api::UsersApi, user_id::String, update_user_active_request::UpdateUserActiveRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_user_active(_api, user_id, update_user_active_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function update_user_active(_api::UsersApi, response_stream::Channel, user_id::String, update_user_active_request::UpdateUserActiveRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_user_active(_api, user_id, update_user_active_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_update_user_auth_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => UserAuthData,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("501", "x"=>".") * "\$") => AppError,
)

function _oacinternal_update_user_auth(_api::UsersApi, user_id::String, user_auth_data::UserAuthData; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_update_user_auth_UsersApi, "/users/{user_id}/auth", ["bearerAuth", ], user_auth_data)
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Update a user's authentication method

Updates a user's authentication method. This can be used to change them to/from LDAP authentication for example.  __Minimum server version__: 4.6 ##### Permissions Must have the `edit_other_users` permission. 

Params:
- user_id::String (required)
- user_auth_data::UserAuthData (required)

Return: UserAuthData, OpenAPI.Clients.ApiResponse
"""
function update_user_auth(_api::UsersApi, user_id::String, user_auth_data::UserAuthData; _mediaType=nothing)
    _ctx = _oacinternal_update_user_auth(_api, user_id, user_auth_data; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function update_user_auth(_api::UsersApi, response_stream::Channel, user_id::String, user_auth_data::UserAuthData; _mediaType=nothing)
    _ctx = _oacinternal_update_user_auth(_api, user_id, user_auth_data; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_update_user_mfa_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("501", "x"=>".") * "\$") => AppError,
)

function _oacinternal_update_user_mfa(_api::UsersApi, user_id::String, update_user_mfa_request::UpdateUserMfaRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_update_user_mfa_UsersApi, "/users/{user_id}/mfa", ["bearerAuth", ], update_user_mfa_request)
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Update a user's MFA

Activates multi-factor authentication for the user if `activate` is true and a valid `code` is provided. If activate is false, then `code` is not required and multi-factor authentication is disabled for the user. ##### Permissions Must be logged in as the user being updated or have the `edit_other_users` permission. 

Params:
- user_id::String (required)
- update_user_mfa_request::UpdateUserMfaRequest (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function update_user_mfa(_api::UsersApi, user_id::String, update_user_mfa_request::UpdateUserMfaRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_user_mfa(_api, user_id, update_user_mfa_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function update_user_mfa(_api::UsersApi, response_stream::Channel, user_id::String, update_user_mfa_request::UpdateUserMfaRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_user_mfa(_api, user_id, update_user_mfa_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_update_user_password_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_update_user_password(_api::UsersApi, user_id::String, update_user_password_request::UpdateUserPasswordRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_update_user_password_UsersApi, "/users/{user_id}/password", ["bearerAuth", ], update_user_password_request)
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Update a user's password

Update a user's password. New password must meet password policy set by server configuration. Current password is required if you're updating your own password. ##### Permissions Must be logged in as the user the password is being changed for or have `manage_system` permission. 

Params:
- user_id::String (required)
- update_user_password_request::UpdateUserPasswordRequest (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function update_user_password(_api::UsersApi, user_id::String, update_user_password_request::UpdateUserPasswordRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_user_password(_api, user_id, update_user_password_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function update_user_password(_api::UsersApi, response_stream::Channel, user_id::String, update_user_password_request::UpdateUserPasswordRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_user_password(_api, user_id, update_user_password_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_update_user_roles_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("403", "x"=>".") * "\$") => AppError,
)

function _oacinternal_update_user_roles(_api::UsersApi, user_id::String, update_user_roles_request::UpdateUserRolesRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "PUT", _returntypes_update_user_roles_UsersApi, "/users/{user_id}/roles", ["bearerAuth", ], update_user_roles_request)
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Update a user's roles

Update a user's system-level roles. Valid user roles are \"system_user\", \"system_admin\" or both of them. Overwrites any previously assigned system-level roles. ##### Permissions Must have the `manage_roles` permission. 

Params:
- user_id::String (required)
- update_user_roles_request::UpdateUserRolesRequest (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function update_user_roles(_api::UsersApi, user_id::String, update_user_roles_request::UpdateUserRolesRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_user_roles(_api, user_id, update_user_roles_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function update_user_roles(_api::UsersApi, response_stream::Channel, user_id::String, update_user_roles_request::UpdateUserRolesRequest; _mediaType=nothing)
    _ctx = _oacinternal_update_user_roles(_api, user_id, update_user_roles_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_verify_user_email_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => StatusOK,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
)

function _oacinternal_verify_user_email(_api::UsersApi, verify_user_email_request::VerifyUserEmailRequest; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_verify_user_email_UsersApi, "/users/email/verify", ["bearerAuth", ], verify_user_email_request)
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? ["application/json", ] : [_mediaType])
    return _ctx
end

@doc raw"""Verify user email

Verify the email used by a user to sign-up their account with. ##### Permissions No permissions required. 

Params:
- verify_user_email_request::VerifyUserEmailRequest (required)

Return: StatusOK, OpenAPI.Clients.ApiResponse
"""
function verify_user_email(_api::UsersApi, verify_user_email_request::VerifyUserEmailRequest; _mediaType=nothing)
    _ctx = _oacinternal_verify_user_email(_api, verify_user_email_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function verify_user_email(_api::UsersApi, response_stream::Channel, verify_user_email_request::VerifyUserEmailRequest; _mediaType=nothing)
    _ctx = _oacinternal_verify_user_email(_api, verify_user_email_request; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

const _returntypes_verify_user_email_without_token_UsersApi = Dict{Regex,Type}(
    Regex("^" * replace("200", "x"=>".") * "\$") => User,
    Regex("^" * replace("400", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("401", "x"=>".") * "\$") => AppError,
    Regex("^" * replace("404", "x"=>".") * "\$") => AppError,
)

function _oacinternal_verify_user_email_without_token(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = OpenAPI.Clients.Ctx(_api.client, "POST", _returntypes_verify_user_email_without_token_UsersApi, "/users/{user_id}/email/verify/member", ["bearerAuth", ])
    OpenAPI.Clients.set_param(_ctx.path, "user_id", user_id)  # type String
    OpenAPI.Clients.set_header_accept(_ctx, ["application/json", ])
    OpenAPI.Clients.set_header_content_type(_ctx, (_mediaType === nothing) ? [] : [_mediaType])
    return _ctx
end

@doc raw"""Verify user email by ID

Verify the email used by a user without a token.  __Minimum server version__: 5.24  ##### Permissions  Must have `manage_system` permission. 

Params:
- user_id::String (required)

Return: User, OpenAPI.Clients.ApiResponse
"""
function verify_user_email_without_token(_api::UsersApi, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_verify_user_email_without_token(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx)
end

function verify_user_email_without_token(_api::UsersApi, response_stream::Channel, user_id::String; _mediaType=nothing)
    _ctx = _oacinternal_verify_user_email_without_token(_api, user_id; _mediaType=_mediaType)
    return OpenAPI.Clients.exec(_ctx, response_stream)
end

export attach_device_id
export autocomplete_users
export check_user_mfa
export convert_bot_to_user
export convert_user_to_bot
export create_user
export create_user_access_token
export delete_user
export demote_user_to_guest
export disable_user_access_token
export enable_user_access_token
export generate_mfa_secret
export get_channel_members_with_team_data_for_user
export get_default_profile_image
export get_known_users
export get_profile_image
export get_sessions
export get_total_users_stats
export get_total_users_stats_filtered
export get_uploads_for_user
export get_user
export get_user_access_token
export get_user_access_tokens
export get_user_access_tokens_for_user
export get_user_audits
export get_user_by_email
export get_user_by_username
export get_user_terms_of_service
export get_users
export get_users_by_group_channel_ids
export get_users_by_ids
export get_users_by_usernames
export login
export login_by_cws_token
export logout
export migrate_auth_to_ldap
export migrate_auth_to_saml
export patch_user
export permanent_delete_all_users
export promote_guest_to_user
export publish_user_typing
export register_terms_of_service_action
export reset_password
export revoke_all_sessions
export revoke_session
export revoke_sessions_from_all_users
export revoke_user_access_token
export search_user_access_tokens
export search_users
export send_password_reset_email
export send_verification_email
export set_default_profile_image
export set_profile_image
export switch_account_type
export update_user
export update_user_active
export update_user_auth
export update_user_mfa
export update_user_password
export update_user_roles
export verify_user_email
export verify_user_email_without_token
